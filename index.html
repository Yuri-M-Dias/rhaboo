<!DOCTYPE html>
<html class='no-js'>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'>
<meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9, minimum-scale=0.9" />
  <title>Rhaboo : JS Persistence Library</title>  
  <link rel="shortcut icon" type="image/png" href="logo.png" />

  <style>
html > *                     { font-family: Arial !important; color: #502000; background-color: white;}
table, tr                    { vertical-align: top;}
table.menu tr td             { cursor: pointer; }
h2, h1                       { text-decoration: underline; }
.cssvwunit     .banner       { vertical-align: bottom; font-size: 15vw; font-weight:bold; margin-left:0px;text-align:right;}
.no-cssvwunit  .banner       { vertical-align: bottom; font-size: 75px; font-weight:bold; margin-left:0px;text-align:right;}
.cssvwunit .subbanner1       { vertical-align: bottom; font-size: 2.5vw; margin-left:0.30em;text-align:right;}
.no-cssvwunit .subbanner1    { vertical-align: bottom; font-size: 13px; margin-left:0.30em;text-align:right;}
.cssvwunit .subbanner2       { vertical-align: bottom; font-size: 2.5vw; text-align:right;}
.no-cssvwunit .subbanner2    { vertical-align: bottom; font-size: 13px; text-align:right;}
.cssvwunit .demo             { vertical-align: bottom; font-size: 1.5vw; text-align:right;}
.no-cssvwunit .demo          { vertical-align: bottom; font-size: 10px; text-align:right;}
.cssvwunit .topmenuitem      { text-align:center; vertical-align: bottom; font-size: 3.5vw; margin-left:0.30em;}
.no-cssvwunit .topmenuitem   { text-align:center; vertical-align: bottom; font-size: 18px; margin-left:0.30em;}
.cssvwunit .secmenuitem      { text-align:center; vertical-align: bottom; font-size: 2.5vw; margin-left:0.30em;}
.no-cssvwunit .secmenuitem   { text-align:center; vertical-align: bottom; font-size: 13px; margin-left:0.30em;}
.cssvwunit .splash, 
.cssvwunit th                { text-align:center; font-size: 2.5vw;}
.no-cssvwunit .splash, 
.no-cssvwunit th             { text-align:center; font-size: 18px;}
.cssvwunit .splashof3        { font-weight:bold; text-align:center; font-size: 3vw;}
.no-cssvwunit .splashof3     { font-weight:bold; text-align:center; font-size: 15px;}
.cssvwunit .detailof3        { padding-left:1vw; padding-right:1vw; text-align:center; font-size: 1.5vw;}
.no-cssvwunit .detailof3     { padding-left:1vw; padding-right:1vw; text-align:center; font-size: 11px;}




.cssvwunit body              { font-size:1.5vw}
.no-cssvwunit body           { font-size:11px}

dt                           { font-weight: bold;}

.boxshadow .boxof3           { box-shadow: 5px 8px 18px 2px #502000; -webkit-box-shadow: 5px 10px 15px #502000; -moz-box-shadow: 5px 10px 15px #502000; width:30% }
.menu                        { table-layout: fixed; background-color:#ffffa0; }
a.plain:link                 { text-decoration: none; color: #502000;} 
a.plain:visited              { text-decoration: none; color: #502000;} 
a.plain:hover                { text-decoration: none; color: #502000;} 
a.plain:active               { text-decoration: none; color: #502000;} 

#api td, #api th             { padding-left: 10px; padding-right: 10px; }
#api dt                      { font-weight:normal; }
#history td, #history th     { font-size:100%; text-align:left; padding-left: 10px; padding-right: 10px; }
#history dt                  { font-weight:normal; }

  </style>

  <script src='rhaboo.max.js'></script>
  <script src='modernizr.custom.42785.js'></script>
  <script>

function vis(name, v) {
  if (name) {
    var ob = document.getElementById(name);
    ob.style.fontWeight=v?"bold":"";
    ob.style.textShadow=v?"-1px 2px #C0C060":"";
    document.getElementById(name.toUpperCase()).style.display=v?"block":"none";
  }
}

var store = Rhaboo.persistent("RhabooHomePage");

function show1(x) {
  vis(store.showing1, false);
  store.write('showing1', x) ;
  vis(store.showing1, true)
}

function show2(x) {
  vis(store.showing2, false);
  store.write('showing2', x) ;
  vis(store.showing2, true)
}

function start() {
  if (!store.showing1) {
    store.write('showing1', 'about') ;
    store.write('showing2', 'demos') ;
  }
  vis(store.showing1, true)
  vis(store.showing2, true)
}

  </script>

<body onload="start();">

    <table width='100%'>
      <tr width='100%'>
        <td width='30%'> <img src='logo.png' width='75%'/> </td>
        <td style='vertical-align: bottom;'>
          <table width='100%'>
            <tr><td class='subbanner1'>Makes JavaScript objects persistent...</td></tr>
            <tr><td class='subbanner2'>...without learning a new API.</td></tr>
            <tr><td class='banner'>rhaboo</td></tr>
          </table>
          <!--
            <span class='subbanner1'>Makes JavaScript objects persistent...</span><br/>
            <span class='subbanner2'>...without learning a new trick.</span><br/>
            <span class='banner'>rhaboo</span><br/>
          -->
        </td>
      </tr>
    </table>
    <table  class='menu' width='100%'><tr width='100%'>
        <td class='topmenuitem' id='about' onClick='show1(this.id);'>about</td>
        <td class='topmenuitem' id='docs' onClick='show1(this.id);'>docs</td>
        <td class='topmenuitem' id='faq' onClick='show1(this.id);'>faq</td>
        <td class='topmenuitem'><a class='topmenuitem plain' href="https://github.com/adrianmay/rhaboo">github</a></td>
        <!--
        <td class='topmenuitem' onClick='window.location.href="https://github.com/adrianmay/rhaboo"'>github</td>
        -->
      </tr>
    </table>
    <div id='ABOUT' style='display:none;'> 
      <p class='splash'>The easiest, fastest and most portable persistence solution on the web</p>
    <table style='vertical-align:top;' width='100%'>
      <tr style='vertical-align:top;'>
        <td></td>
        <td class='boxof3'>
          <p class='splashof3'>Easy</p>
          <p class='detailof3'>Makes regular JS objects persistent. <br/><br/>No new storage paradigm to learn.
        </td>
        <td></td>
        <td class='boxof3'>
          <p class='splashof3'>Full</p>
          <p class='detailof3'>Stores objects nested to any level. <br/><br/>All standard array functions work persistently. <br/><br/>Supports non-numeric properties of arrays.
        </td>
        <td></td>
        <td class='boxof3'>
          <p class='splashof3'>Fast</p>
          <p class='detailof3'>Stores components of objects separately rather than just stringifying and parsing the whole thing at every little change. <br/><br/><a href='performance/many-ints.rhaboo.html'>Rhaboo</a> vs. <a href='performance/many-ints.forage.html'>localForage</a><br/>3600x faster on firefox<br/>870x faster on chrome
        </td>
        <td></td>
      </tr></table>
        <br/>
      <table style='vertical-align:top;'><tr style='vertical-align:top;'>
        <td></td>
        <td></td>
        <td class='boxof3'>
          <p class='splashof3'>Portable</p>
          <p class='detailof3'>Only relies on localStorage.
        </td>
        <td></td>
        <td class='boxof3'>
          <p class='splashof3'>Reliable</p>
          <p class='detailof3'>Our automatically generated test script contains roughly 20,000 assertions.
        </td>
        <td></td>
        <td></td>
      </tr>
    </table>     
     
    <br/>
     <p>For instance:
      <pre>
&lt;script src='rhaboo.min.js'&gt;&lt;/script&gt;
&lt;script&gt;
  <span style='color:green;'>//Open a persistent object called 'Some name'...</span>
  <b>var store = Rhaboo.persistent('Some name');</b>
  <span style='color:green;'>//If it has a property called 'count' then increment it, </span>
  <span style='color:green;'>//otherwise initialise it to 1...</span>
  <b>store.write('count', store.count ? store.count+1 : 1);</b>
&lt;/script&gt;
&lt;body onLoad='
  document.getElementById("count").
    <span style='color:green;'>//Use it like a normal object...</span>
    <b>innerHTML = store.count</b>;'&gt;
  &lt;p&gt;You loaded this page &lt;span id='count'&gt;&lt;/span&gt; times.
&lt;/body&gt;
      </pre>
      <p>So having made <code>store</code> with that "constructor", it behaves just like a normal object except that wherever you'd normally write <code>store.key=val</code> you should write <code>store.write('key', val)</code> instead. Furthermore, any objects or arrays inside a persistent one also have that <code>write</code> function: 
      <br/>
      <br/>
      <pre>
store.write('somethingfancy', {
  one: ['man', 'went'],
  2: 'mow',
  went: [  2, { mow: ['a', 'meadow' ] }, {}  ]
});

store.somethingfancy.went[1].mow.write(1, 'lawn');
      </pre>
      <p>That is quite literally all you need to know.

      <table width='100%'>
        <tr>
          <td></td>
          <td class='boxof3'>
            <a class='download plain' href="https://raw.githubusercontent.com/adrianmay/rhaboo/master/rhaboo.min.js" download><div class='splashof3' style='padding-top:50px; padding-bottom:50px; '>Download</div></a>
            <p class='detailof3'>rhaboo.min.js<br/>7.6k 
          </td>
          <td></td>
        </tr>
      </table>
      <br/>
      <p class='splash'>Free and Open Source.</p>
      <center>
        <script data-gratipay-username="adrianmay"
                data-gratipay-widget="button"
                src="//gttp.co/v1.js"></script>
        <table>
          <tr>
            <td>
              <img width='25px' height='25px' src=bitcoin.png></img>1YF83SfzgR8ZjjuMe9RdFvFkc78UFwEn9
            </td>
          </tr>
        </table>
      </center>
      <br/>
    </div>
    <div id='DOCS' style='display:none;'> 
      <table  class='menu' width='100%'><tr width='100%'>
          <td class='secmenuitem' id='install' onClick='show2(this.id);'>install</td>
          <td class='secmenuitem' id='demos' onClick='show2(this.id);'>demos</td>
          <td class='secmenuitem' id='reference' onClick='show2(this.id);'>reference</td>
          <td class='secmenuitem' id='internals' onClick='show2(this.id);'>internals</td>
          <td class='secmenuitem' id='tests' onClick='show2(this.id);'>tests</td>
        </tr>
      </table>
      <div id='INSTALL' style='display:none;'> 
        <p>There are several options:
        <ol>
          <li>Just grab <a href='https://raw.githubusercontent.com/adrianmay/rhaboo/master/rhaboo.min.js'>rhaboo.min.js</a> and put the script tag in your document.<br/><br/></li>         
          <li>In the directory where your html is:<pre>npm install rhaboo</pre> then write a script tag pointing at <code>node_modules/rhaboo/rhaboo.min.js</code><br/><br/></li>         
            <li>If you want to edit and build rhaboo then do this:<pre>
git clone https://github.com/adrianmay/rhaboo.git
cd rhaboo
npm install grunt grunt-contrib-uglify grunt-browserify seedrandom ajon parunpar
grunt    # be patient with this
            </pre></li>         
        </ol>
      </div>
      <div id='DEMOS' style='display:none;'> 
        <p><a class='demo plain' href='index.html'>This web page uses rhaboo (around line 70) to remember where you were in the menus</a> 
        <p><a class='demo plain' href='demos/index.html'>All demos</a> 
        <p><a class='demo plain' href='demos/counter.html'>Reload counter</a> 
        <p><a class='demo plain' href='demos/cliches.html'>Simple database</a> 
        <p><a class='demo plain' href='demos/game.html'>Tiles game</a> 
        <p><a class='demo plain' href='demos/oo.html'>Object orientation</a> 
        <p>You can run these in Firefox OS Simulator by installing the manifest (which is in rhaboo's root directory.)
        <p><span style="color: red" onClick='
                 for (var i in localStorage) if (localStorage.hasOwnProperty(i)) localStorage.removeItem(i);
                 this.innerHTML="Nuked.";
           '>Nuke localStorage</span>
      </div>
      <div id='REFERENCE' style='display:none;'> 
        <table id='api' width='100%'>
          <tr><td colspan=4><hr/></td></tr>
          <tr>
            <th width='33%'>API</th>
            <th>Description</th>
            <th>Parameters</th>
            <th>Returns</th>
          </tr>
          <tr><td colspan=4><hr/></td></tr>
          <tr>
            <td><code>Rhaboo.persistent(name)</code></td>
            <td>Returns root persistent object. The library looks for entries in localStorage corresponding with the passed name and loads any previously persisted data into the returned object. If no data is found, a mostly empty object is returned, 'mostly' meaning that it just has a property called <code>_rhaboo</code> which is used for internal purposes.</td>
            <td>
              <dt><code>name:</code></dt><dd>Any text name that's not likely to be the same as any other.</dd> 
            </td>
            <td>The persistent object.</td>
          </tr>
          <tr><td colspan=4><hr/></td></tr>
          <tr>
            <td><code>Object.prototype.write(key, val)</code></td>
            <td>Persistent replacement for = operator. <code>store.write('key',val)</code> is equivalent to <code>store.key=val </code>except with persistence. Can be applied to objects inside the root persistent as well as the root persistent itself.
            </td>
            <td>
              <dt><code>this:</code></dt><dd>The object whose property we're adding or changing</dd> 
              <dt><code>key:</code></dt><dd>The property name within <code>this</code></dd> 
              <dt><code>val:</code></dt><dd>The new value for the property. Any javascript type is acceptable, but functions and regexes will not persist.</dd> 
            </td>
            <td><code>this</code></td>
          </tr>
          <tr><td colspan=4><hr/></td></tr>
          <tr>
            <td><code>Object.prototype.erase(key)</code></td>
            <td>Persistent equivalent of <code>delete object.key</code>. Completely removes a property. This is not the same as setting it to undefined. Don't use it on arrays. Use splice instead.</td>
            <td>
              <dt><code>this:</code></dt><dd>The object whose property we're adding or changing</dd> 
              <dt><code>key:</code></dt><dd>The property name within <code>this</code></dd> 
            </td>
            <td><code>this</code></td>
          </tr>
          <tr><td colspan=4><hr/></td></tr>
        </table>
        <h1>Version History</h1>
        <p>Warning: rhaboo uses semver, so a major version change WILL be a breaking change. Make sure you specify the major version you are coding against and use the latest within that range.
        <table id='history' width='100%'>
          <tr>
            <th>Version (current = 3.0.1)</th>
            <th>Changes</th>
          </tr>
          <tr>       <td>2.0.5</td>          <td>First anybody has heard of</td>          </tr>
          <tr>       <td>2.0.6</td>          <td>Code cleanup: Remove where from _rhaboo</td>          </tr>
          <tr>       <td>2.0.7</td>          <td>Dumped q and enq.js and just used setTimeout instead</td>          </tr>
          <tr>       <td>3.0.0</td>          <td>Total rewrite aiming to restore constructors/prototypes and support multiple persistent refs to the same object.<br/>Huge speed boost. Breaks API.<br>New features not tested yet, but old tests succeeding.</td>          </tr>
          <tr>       <td>3.0.1</td>          <td>Little bug fixes</td>          </tr>
          <tr>       <td>3.1.0</td>          <td>Support Date objects</td>          </tr>
        </table>
      </div>
      <div id='TESTS' style='display:none;'> 
        <p>This will erase any data in the demo apps...
        <p><a href='http://rhaboo.org/generate-tests/generated-pages/page.0.html'>Run tests</a>
        <p><a href='performance'>Performance comparisons (WIP)</a>
      </div>
      <div id='INTERNALS' style='display:none;'>
        <h2>Modules, namespaces, etc</h2>
        <p>Each source file uses node.js-style modularisation: the important exports are written in something called <code>module.exports</code> which acquires a local name when <code>require</code>d by another module. For instance, within core.js, the <code>execute</code> function is called <code>execute</code>, but because arr.js imports it as "<code>R</code>" it must be referred to as <code>R.execute</code> in that file. 
        <p>Browsers don't have a <code>require</code> statement so the 'browserify' preprocessor is used to read them and output a source file combining all the modules. If you're using browserify, then arr.js is the thing to import.
        <p>It's not desirable to force people to use browserify, so there's also a source file called unbrowserify.js that uses browserify to import arr.js (which exports everything useful) and assigns it to a regular variable called <code>Rhaboo</code>. The final scripts rhaboo.max.js and rhaboo.min.js are based on unbrowserify.js. Functions that live in <code>Object.prototype</code> or <code>Array.prototype</code> are available without that unbrowserification.
        <p>Namespace pollution is restricted to names beginning with <code>_rhaboo</code> (except <code>write()</code> and <code>erase()</code>) and the <code>Rhaboo</code> object. 
        <h2>Dependencies</h2>
        <p>Rhaboo has 2 source files: <ul>
          <li>core.js which depends on 'parunpar': another repo and npm module by the same author,</li>
          <li>arr.js which depends on core.js</li>
        </ul><p>There are no other dependencies.
        <p>There's also a huge test script generator which depends on another repo by the same author called ajon. This is a more accurate but less readable version of JSON. Rhaboo itself does not use ajon, only the test script generator does.
        <h2>parunpar</h2>
        <p>This is documented in its own repo, but in a nutshell, it supports compact serialisation of known data in a known way. The core abstraction is a that of a parunpar: a function of boolean which returns an encoder or corresponding decoder in return for true or false respectively. An encoder takes a data structure (often a bunch of nested arrays) and returns a string, while the corresponding decoder takes that string and returns a data structure identical to the original one. There are combinators that build complex parunpars out of simple ones.
        <h2>Use of localStorage</h2>
        <p>Rhaboo uses parunpar to define the linear encoding used in individual localStorage entries. These entries come in two types corresponding to objects and properties. Both types have a left hand side and may have a right hand side separated from the LHS by a semicolon. For objects, the LHS records the constructor and the length (if defined) for the object. For properties, the LHS comprises the type and a string representation of the value. 
        <p>The RHS is the same in both cases: it implements a linked list of properties where the link contains both the name of the next property and the localStorage location where its type and value can be found, perhaps accompanied by a link to yet another property. The RHS of an object entry points to the first property entry, then subsequent properties are found by following the RHSs of properties already found. This peculiar habit of putting the property name in the link to it rather than its own entry has neither advantages nor disadvantages.
        <p>If a property is an object rather than a basic type, then its entry will be a reference (this being a sixth basic type in rhaboo after the three usual ones, null and undefined) to a localStorage location where the object itself is stored using an object entry. 
        <p>Root persistent entries are just like any other object: the object is represented independently of any name or reference to it. The name passed to <code>Rhaboo.persistent</code> resolves to a localStorage entry in which a <i>reference</i> to the object is found, not the object itself. This extra level of indirection is necessary to support multiple persistent references to the same object.
        <p>Here's a peep into the localStorage usage of the cliches demo:

        <center>
          <table>
            <tr>
              <td>
                <img src='peep.png'></img>
              </td>
              <td style='vertical-align:bottom;'>
                <b>Key:</b><br/>
                _ : undefined<br/>
                ~ : null<br/>
                $ : string<br/>
                # : number<br/>
                ? : boolean<br/>
                &amp; : reference<br/>
              </td>
            </tr>
          </table>
        </center>

        <p>At the top we see how localStorage keys are generated. There is no attempt to reuse freed numbers. At the bottom we see a reference to slot 0 (i.e. localStorage entry "_rhaboo_0") under a name derived from the parameter to <code>Rhaboo.persistent</code>. The referenced object is constructed with the Object function and has no meaningful length. Its first property is called 'initialised' and lives in slot 1 where we can see the type (? means boolean) and the value (t means true for booleans). The next property is called 'cliches' and lives in slot 2 where we see a reference to slot 3 in which an object constructed with 'Array' with a length of 3 can be found. It has a property called '0' which lives in slot 4 which contains yet another reference, etc, etc.
        <h2>Kids</h2>
        <p>A persistent object needs to store some information in memory about how it is persisted. This is all in a property called _rhaboo in each persistent object.
        <p>The localStorage entries for the properties of a given object hang together in a singly linked list. This is adequate for restoration which occurs in one go at an early stage. However, for updates during run time, we'll often need the predecessor of a given property (e.g. when deleting it) and should therefore have a doubly linked list for decent performance. This doubly linked list is called 'kids' and is a property of _rhaboo. The main purpose of each item in the list is to store the localStorage slot for the property. Within the scope of a given object, there are functions to append a new kid (i.e. property name to slot number mapping) to the end of the list, and to remove the kid for a specified property name from the list. 
        <p>_rhaboo itself has some similarities with the kids and is often treated as such. Specifically, while the members of a kid are called <code>slotnum</code>, <code>next</code> and <code>prev</code>, _rhaboo also has a <code>slotnum</code> navigating to the object slot, a pointer to the head of the kid list called <code>next</code> and to its tail called <code>prev</code>. Anything called <code>prev</code> or <code>next</code> has the value <code>undefined</code> if there is nothing meaningful for it to point at. Otherwise they take a string value which is the property name of what they point to. This property name is both the actual name of the property within the object, and the key within the kid list.
        <h2>Restoration</h2>
        <p>The per-entry aspect of restoration is performed by the parunpars. There's one for objects and another for properties. We always know which to apply to a given slot before examining the contents of that slot. For objects, the entry contains a string and maybe a number. When encoding, the string is obtained from the constructor (usually inherited from the prototype) and the number from the length property. When decoding, the global object is searched for a function named like the string and called with the number as a parameter. 
        <p>For entries for properties of the 3 basic types, the encoder prepends a single-charater type code to a stringification of the value and the decoder uses the type character to choose a converter to apply to the stringification. For null and undefined types no stringification is required. For references, the thing to stringify is the slot number of the referred object. This is read out of _rhaboo during encoding, and during decoding the number is passed to <code>restore</code> which returns the newly restored object.
        <p>This <code>restore</code> function is where the recursion along RHS links through the properties is triggered. In the context of a partially restored object and a property slot, <code>augment()</code> inserts the property into the object, looks for another link and recurses into <code>augment()</code>. The <code>restore()</code> function does some object-specific basics like setting up an empty kids list and then starts the <code>augment()</code> recursion if there's a RHS in the object slot.
        <p>Another function of <code>restore()</code> is to keep a map of slot numbers onto restored objects. This is used to reuse already restored objects in the case of multiple references to them. This map is not needed after the initial restore.
        <h2>Update</h2>
        <p>When keeping the store up to date, the immediate user of the parunpar encoder is the <code>updateSlot()</code> function. This just gathers the information to be encoded in the form expected by the parunpar, encodes it and writes a script entry for its persistence. This function works for both property and object slots according to whether the prop parameter is defined or not. 
        <p>Property and object slots get a slot allocated to them in different ways. For properties, the <code>slotFor()</code> function may be called more or less anytime. It does not return a value but ensures that the slot number is written in the containing object's kids list under the property name. This might already be true when <code>slotFor()</code> is called, but if not, a slot is grabbed, the kid is created and the <i>preceeding</i> slot is updated in localStorage. This is the slot that links the new one into the greater scheme of things. As for the new slot itself, some data is about to be written in the property after which it will be persisted, so there's no need to do so during <code>slotFor()</code>.
        <p>Persistent objects are reference counted, as must be the case in a system supporting multiple references to the same object. A non-persistent (i.e. ordinary JS) object has no _rhaboo property and an implicit refcount of zero. We can call <code>addRef()</code> on such an object and it will acquire an _rhaboo with a kids list, a new slot and a refcount of 1. Subsequent <code>addRef()</code> calls just increase the refcount. The refcount can be decreased with <code>release()</code> and if it reaches zero, then all traces of its persistence will be obliterated and its _rhaboo deleted. Both <code>addRef()</code> and <code>release()</code> deal with all the properties, recursing into any object-valued ones. Both functions take some extra parameters used by the persistent array mutators as discussed later.
        <p>The write and erase functions should now be self explanatory. The latter looks a bit messy, doing things that one might think <code>removeKid()</code> should do, but <code>removeKid()</code> has no idea about scripts or persistence: it just administers the kid list structure. This is by design.
        <h2>arr.js</h2>
        <p>This is where the 7 array operations: <code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>splice</code>, <code>sort</code> and <code>reverse</code> (plus maybe <code>fill</code> if it's available) are made persistent. The original functions are stashed and used by the new persistent ones. 
        <p>In the worst case scenario that the array is totally rewritten, e.g. by a <code>sort</code>, our strategy is to use <code>release()</code> and <code>addRef()</code> in a rather forceful way. We note the refcount and slot number, then call <code>release()</code> with <code>force=true</code> which means obliterate the persistence irrespective of the refcount. Then we call the standard version of the mutator followed by <code>addRef()</code> with the saved values of the refcount and slot number, which are adopted by the object.
        <p>For <code>push</code> and <code>pop</code> we can do a lot better because we know that most of the array is unaffected. For <code>pop</code>ping, we unpersist the <code>(length-1)</code>th property and update the object slot to reflect the new length. There are odd cases where the kid for the popped property doesn't exist: make a populated array sparse by writing something way beyond the length, then sort it. The sparse entries (which do not contain null or undefined but simply don't exist) are sorted to the end and the <code>(length-1)</code>th doesn't exist. Rhaboo doesn't want to create kids for all these sparse entries so it just dodges the flames when an attempt is made to delete the non-existent kid in pop. For pushing, we note the old and new lengths and persist everyting in between, again, updating the object slot for the new length.
        <h2>Test Automation</h2>
        <p>Seeing as this library is about persistence, the test script has to run over multiple pages.
        <p>The test system consists of a grunt task in generate-tests/tasks/gentest.js that writes a set of html pages, each accompanied by a JS file containing a test script. These end up in generate-tests/generated-pages. The test script is a JS object to be interpreted by the page with the help of generate-tests/runner.js. 
        <p>Let's look at some script:
        <pre>
var page = 0;
var persistents = {
   "P1000001": [
      {
         "action": "write",
         "path": [
            "P1000002"
         ],
         "vehicle": "{&lt;val&gt;=[(5):&lt;0&gt;=(2);&lt;1&gt;=!;&lt;2&gt;=&lt;blah&gt;;&lt;3&gt;=[(3):&lt;0&gt;=(3);&lt;1&gt;=@;&lt;2&gt;=&lt;ecky&gt;;];&lt;4&gt;={&lt;a&gt;=&lt;asdf&gt;;&lt;b&gt;=@;};];}",
         "expect": "{&lt;P1000002&gt;=[(5):&lt;0&gt;=(2);&lt;1&gt;=!;&lt;2&gt;=&lt;blah&gt;;&lt;3&gt;=[(3):&lt;0&gt;=(3);&lt;1&gt;=@;&lt;2&gt;=&lt;ecky&gt;;];&lt;4&gt;={&lt;a&gt;=&lt;asdf&gt;;&lt;b&gt;=@;};];}"
      },
        </pre>
        <p>The hieroglyphics in <code>vehicle</code> and expect are a notation called ajon which is like JSON but more accurate and less readable.
        <p>The instruction is to open a root persistent called P1000001, write to its property called P1000002 a value of [2,false,'blah',[3, true, 'ecky' ],{ a:'asdf', b:true }] and then expect P1000001 to contain just that. After all, this is the first instruction in the whole test script and runner.js will erase localStorage before starting. There are more changes to P1000001 on this and subsequent pages so expect will often contain data left over from earlier actions. Actions are not always writes - they can also be array operations or kills( i.e. erasures.)
        <p>gentest.js works by making up a series of actions, applying them to normal objects in memory and writing the contents of those objects after each operation into the expect field. The runner works by repeating the same sequence over a number of pages and checking the results against the expect field. If persistence is working properly, the page breaks should have no effect.
        <p>The script, then, is a list of pages, each containing a list of root persistents, each containing a list of action-expect steps. But that's not how it gets designed. Rather, we start with a reasonably versatile list of 'stories' as to what a given property might experience. The model for that is three operations, each optionally followed by a page break, and each being either a kill or a write using a specified type. With 8 types (string or bool, number, empty object, populated object, empty array, populated array, undefined, null) that makes 9*2*9*2*9*2=5832 different stories including 2.5*5832=14580 page breaks. The first step of gentest.js is to calculate these stories and store them in a random order. 
        <p>The next step is to hand the stories out to a range of root persistents and sub-objects thereof. We make variables for the current target persistent and target path within it, then step through the stories and 'episodes' of the stories, writing script steps that apply each episode to the current target (i.e. whatever is in the current persistent along the current path,) fill in values for the parameters of the write episodes, and bump the target around as we go along. That bumping around includes at each step a certain probability of: starting a whole new persistent, diving deeper into the current target if it is an object, popping up to the current target's parent, or skipping to a sibling. When reading that code, one should note that the current path doesn't need to point at something that exists because we're about to write it anyway, but the penultimate step in the path must point to an object (or array.)
        <p>This is a script that we can actually run on normal JS objects to get the expected values. But it's got about 15000 pages and only one persistent on each. So we separate the script of each persistent from every other, then reallocate them to pages in parallel. Now the number of pages equals the length of the longest per-persistent script, and the first page is the busiest. Unfortunately this leads to a geometric distribution of persistents over pages with a ludicrously long tail of very short pages towards the end, so we clip that by modifying the handing-out process to forcibly hop to a new persistent if there have been too many page breaks while this persistent was target. 
        <p>It only remains to write the actual html and JS files for each page.
        <p>Array support got added to this automat as an afterthought. The solution was to reinterpret the episode codes when there's an array in the current target. There's a 50/50 chance that they are still interpreted as usual, but they may be taken to refer to array functions instead. So the code that normally means "write a number" might now mean "pop".
        <p>Is this an exhaustive test? Well, it thoroughly tests what it tests, but testing is a creative job and there's no guarantee that bugs can't be lurking in places this test script never thought of. For instance, it was discovered that <code>JSON.stringify</code> failed on persistents because a child of the <code>_rhaboo</code> property pointed to the parent object, causing a circular reference. That has been fixed, but none of these 20,000 assertions discovered the problem.
      </div>
    </div>
    <div id='FAQ' style='display:none;'> 
      <dl>
        <dt>Why is it called rhaboo? </dt>
        <dd><p>Because nothing else is, not in any language. </dd>
        <dt>Why an owl?</dt>
        <dd><p>Because proboscis monkeys aren't that pretty after all.</dd>
        <br/>
        <dt>What licence is it released under?</dt>
        <dd><p>MIT</dd>
        <dt>How do I get support?</dt>
        <dd><p>You can create an issue on github or ask a question on stackoverflow. Please create the <code>rhaboo</code> tag if you can.</dd>
        <dt>Can I contribute?</dt>
        <dd><p>Can I stop you? There are several open issues calling for better ideas than I can think of. Just chat on the issue tracker. You can also fork the project and ask for a merge.</dd>
        <br/>
        <dt>How fast is it?</dt>
        <dd><p>Proper performance tests are in the pipeline, but it must be very fast because localStorage is a simple mechanism and it's being used in a very efficient way. However, those array functions like reverse and sort which change the whole thing are a bit slow right now.</dd>
        <dt>What can't it do?</dt>
        <dd>
        <p>Function-valued and regex-valued properties of objects are ignored. If you want regexes just ask. 
        <p>There's no protection for the case that the user closes the window while background persistence jobs are still going on. For most programs this is highly unlikely because you won't be firing off huge persistence jobs, but if it is a concern, you can roll your own journalling checks. For instance, you'll gradually write the new version of the sub-object in a temporary place, atomically write that it's the important one, and then gradually delete the old one. The UI thread will have returned to responsiveness much earlier than this. If there's demand for rhaboo to do this kind of thing itself, then it'll be developed.</dd>
        <dt>What can it do that most libraries can't?</dt>
        <dd><p>Most libraries either force you to learn a new storage paradigm or limit themselves to single-level maps like what localStorage already gives you. 
        <p>Some libraries store multi-level objects by stringifying and parsing the whole thing, but that's very slow if you just want to add a thousandth element to a list. Furthermore, they suffer the limitations of JSON, namely, that non-numerically named properties of arrays are dropped and sparse entries are filled with nulls. This is very different from objects or arrays in memory where null, undefined and non-existent are all different states for a property. This causes hard to diagnose bugs.
        <p>Other libraries switch between underlying persistence mechanisms according to what the browser can do, but there's no advantage in that for the programmer. You still have to decide whether your program is so simple that raw localStorage will do, or so complex that you'll need WebSQL polyfill, or somewhere in between. You have to decide what paradigm you want to think in, and having done so, you'll want a library that does exactly that and no more.  
        <p>The overwhelming advantage of rhaboo is that by simply replacing your assignments with <code>write</code> calls one-to-one, you can completely forget about the whole persistence issue.</dd>
        <dt>Why do I need to use <code>store.write('key', val)</code> instead of just <code>store.key=val</code>?</dt>
        <dd><p>Because there's no way of overriding assignment in the case that <code>key</code> is something new.</dd>
        <dt>Why doesn't it support regexes?</dt>
        <dd><p>Because nobody asked me to.</dd>
        <dt>Why doesn't it support functions?</dt>
        <dd><p>Because <code>toString</code> on a closure doesn't work, and persisting simple, fixed functions is pointless. The only functions you'd want to persist are those you'd worked out at runtime, for instance, by referring to variables in the same scope and expecting those variables to have values in the function definition. That's what you can't serialise with <code>Function.toString</code> - you just get the original variable name instead of its value:
        <pre>
&gt; f = function(x) { return function(y) {return x+y} }(10)
[Function]
&gt; f(5)
15
&gt; f.toString()
'function (y) {return x+y}'
        </pre>
        <p>Supporting the persistence of objects would thus impose subtle bugs on anybody who tried to use the feature and it's probably better to recommend only storing objects that are all data. In simple cases though, it will soon be possible to inherit functions from a prototype into a data-only persistent.</dd>
        <dt><p>To what extent does it restore the prototype and/or constructor?</dt>
        <dd>
        <p>If you do Crockford style without a valid <code>.constructor</code> pointer, then there's no chance. The reason is that rhaboo knows neither whether nor where there might be a reference to your persistent object's prototype. It might only have been defined on the fly in the call to <code>Object.create({ like: "this" })</code>. Rhaboo would therefore have to store the prototype, but with functions not working properly that would be pointless (functions being the main thing that one finds in a prototype.)
        <p>If I asked you to put a reference to the prototype somewhere in the global scope where rhaboo could find it, and then to write something in the object to say which reference to use, then how about this for a standard: the object should contain or inherit a property called <code>constructor</code> which refers to a global object (let's call it the "constructor") which contains a reference to your prototype called <code>prototype</code>. The advantage of this standard is that people have heard of it before. Furthermore, if, during restoration, the constructor turns out to be a function then rhaboo will use it for creating your restored object. This may involve some wasted effort setting up default values of properties that will be overwritten whilst restoring the details of the object, but that's not a huge problem. It is nevertheless worthwhile to use the constructor function because the initialisation in the constructor might affect things elsewhere in the program. Another good reason is for inserting functions (which rhaboo can't help with.)
        <p>The above assumes that the prototype is a static thing that rhaboo will find in its one and only proper state, but OTOH it might contain class-scoped a.k.a. static properties which need to be restored. In that case the prototype would have to live in the persistent store. With the above features in place though, this would go wrong because <code>.constructor</code> of a prototype is that of the objects of the class it represents, not of the prototype itself. The restoration mechanism would see that value of <code>.constructor</code> and try to make an instance of the class where the prototype should be. Together with the difficulties of persisting functions, the wise approach is that all prototypes should be immutable and refer to some external persistent object for class-scoped mutable data. 
        <p>Under this system, if you program Crockford style and completely ignore <code>prototype.constructor</code>, the latter will usually point to <code>Object</code> and that's what you'll get back, no matter what prototype you passed to <code>Object.create</code>. To fix that without forcing you into the classical model, rhaboo could detect that the constructor is not a function and interpret it as your prototype instead. But this would not be any easier for you than just making an empty function with a prototype property. You'd still have to write a line to set the constructor of your object (or something in its prototype chain) to something other than its default. 
        <p>The conclusion is that only classical inheritance can be supported. Constructor functions must have names and be found under that name in the global object. (Earlier incarnations of Crockford style involved anonymous or temporary constructor functions but this would fail too.) If multiple levels of inheritance are being used then a line like <code>Foo.prototype.constructor=Foo</code> may be required. Prototypes may not be persisted like ordinary objects. Constructor parameters won't be supplied during restoration, but if the constructor doesn't barf about not receiving parameters, then the subsequent restoration of properties might do whatever the constructor wanted those parameters for. 
        <p>And that, finally, really is all you need to know.
        </dd>
        <dt></dt>
        <dd></dd>
        
      </dl>
    </div>
